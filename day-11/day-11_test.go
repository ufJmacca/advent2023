package main

import (
	"fmt"
	"reflect"
	"testing"
)

type puzzle_input_1 struct {
	input      string
	empty_rows int
	result     int
}

type grid_expansion struct {
	input      [][]string
	empty_rows int
	result     [][]string
}

type shortest_path struct {
	grid   [][]string
	start  coords
	end    coords
	result int
}

func TestPuzzle1(t *testing.T) {
	test_data := []puzzle_input_1{
		{`...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....`, 1, 374},
	}

	for _, datum := range test_data {
		result := Puzzle1(datum.input, datum.empty_rows)

		if result != datum.result {
			t.Errorf("Puzzle1(%s) FAILED - Expected %d Got %d\n", datum.input, datum.result, result)
		} else {
			t.Logf("Puzzle1(%s) PASSED", datum.input)
		}
	}
}

func TestGridExpansion(t *testing.T) {
	test_data := []grid_expansion{
		{[][]string{
			{".", ".", ".", "#", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{"#", ".", ".", ".", "#", ".", ".", ".", ".", "."},
		}, 1, [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
		}},
	}

	for _, datum := range test_data {
		result := GridExpansion(datum.input, datum.empty_rows)

		if !IsEqual(result, datum.result) {
			t.Errorf("GridExpansion(%s, %d) FAILED - Expected %s Got %s\n", datum.input, datum.empty_rows, datum.result, result)
		} else {
			t.Logf("GridExpansion(%s, %d) PASSED", datum.input, datum.empty_rows)
		}
	}
}

func TestShortestPath(t *testing.T) {
	test_data := []shortest_path{
		{[][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
		}, coords{x: 0, y: 4}, coords{x: 10, y: 9}, 15},
		{[][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
		}, coords{x: 2, y: 0}, coords{x: 7, y: 12}, 17},
		{[][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
			{"#", ".", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
		}, coords{x: 11, y: 0}, coords{x: 11, y: 5}, 5},
	}

	for _, datum := range test_data {
		result := ShortestPath(datum.grid, datum.start, datum.end)

		if result != datum.result {
			t.Errorf("ShortestPath(%s, %d, %d) FAILED - Expected %d Got %d\n", datum.grid, datum.start, datum.end, datum.result, result)
		} else {
			t.Logf("ShortestPath(%s, %d, %d) PASSED", datum.grid, datum.start, datum.end)
		}
	}
}

func IsEqual(a [][]string, b [][]string) bool {
	if len(a) != len(b) {
		fmt.Println("return false")
		return false
	}
	for i := range a {
		if !reflect.DeepEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

func TestPuzzle2(t *testing.T) {
	test_data := []puzzle_input_1{
		{`...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....`, 2, 374}, {`...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....`, 10, 1030}, {`...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....`, 100, 8410},
	}

	for _, datum := range test_data {
		result := Puzzle2(datum.input, datum.empty_rows)

		if result != datum.result {
			t.Errorf("Puzzle2(%s, %d) FAILED - Expected %d Got %d\n", datum.input, datum.empty_rows, datum.result, result)
		} else {
			t.Logf("Puzzle1(%s, %d) PASSED", datum.input, datum.empty_rows)
		}
	}
}
